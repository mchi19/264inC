Programming Assignment #3

Please read this entire document before starting your assignment or asking for help. If
you ask for help, then you may be asked to read this document. The USEFUL INFORMATION
section at the end has a lot of helpful knowledge for this assignment.

#####Description of Task#####
In the previous programming assignment you implemented functions that are already a part of
the C string library. In this assignment you will be creating more advanced string
processing functions that are not a part of the C string library. The goals of this
assignment are to:

#1 Manage memory properly using malloc and free
#2 Understand how to use arrays and pointers
#3 Understand passing by reference
#4 Learn how to use the qsort C library function
#5 Learn how to use Valgrind to check for memory errors in your code
#6 Understand how to run your code under gdb

We have not created the answer03.c file, so you will have to create on yourself. Read the 
descriptions and definitions of the function you need to complete in answer03.h and write out 
your answer03.c accordingly.

main.c has a bug in it, you must fix it and include it as a part of your submission. 
You are strongly encourage to test your functions as you write your code. We ask that you create
your own file with a main function for this purpose as opposed to using the main function in 
main.c.

In addition to the tasks described in answer03.h, we are asking that you run you program with 
Valgrind and gdb. As shown in class, Valgrind and gdb can be useful for detecting memory errors 
and bugs in your code. To prove that you ran your code with these programs, we ask that you 
generate logs for each one. Details on how to do so are described later in this README.

#####Working on main.c#####
You can compile main.c as its own program with the following command:

> gcc -Wall -Wshadow -g main.c -o a.out

In main.c, the swapString function does not work properly and you must fix it as a part of your 
submission. This is a relatively small task, but it is illustrative.

You will also use main.c to generate Valgrind and gdb logs. You can find more info on that in later sections of the README

#####Working on answer03.c#####
As mentioned above, answer03.h contains the definitions of the functions you need to write. 
These functions must be placed in a file called answer03.c. This file must not have a main(...) 
function and you should create a separate file with a main function if you would like to test 
your code.

You will save yourself a lot time if you test your code as you write it. Test every part of 
every function as you write it. If you wait until the very end before testing your functions and 
they do not pass the tests, it will be a lot more difficult to determine what is causing the 
test failure because the bug could reside in many possible parts of your code.

#####Using Valgrind#####
Valgrind is an extremely useful software tool that, among other things, will allow you to make sure that you 
have no memory errors in your program. For this purpose, we will be focusing on the "memcheck" function of 
Valgrind. The memcheck function runs your code in an emulated environment, and checks whether you access any 
bits of memory that you shouldn't. Memcheck also tests to see if you have allocated (asked for) memory that 
you never freed (gave back). These two memory errors cause a lot of issues in programs, but Valgrind can help 
you find them.

To run your code under Valgrind, you must first compile your code, and then type the following into the terminal:

> valgrind --tool=memcheck --leak-check=full --verbose --log-file=memcheck.log ./a.out

This *runs* your program, but to check for errors, you must check the log file that you just generated: "memcheck.log". This 
file contains a lot of information. If your solution has no memory errors, then you will see at the end of the file something 
along the lines of:

   ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
   
Don't worry about suppressed errors: they are not errors. When your program runs, the C runtime (almost always) 
performs a few memory tricks in order to execute more efficiently. Memcheck picks up these advanced programming 
tricks, and then they are suppressed because it is well-known that these tricks are not errors. Valgrind offers 
these error suppression facilities because they are required by advanced developers who work on important "glue" 
code that holds modern operating systems together. In short: don't worry about suppressed errors. Google is your 
friend if you are interested in more information; however, it will not be tested in this course.

In order to pass this assignment, you must submit a log file produced by Valgrind. Please look at the log so you can 
familiarize yourself with the output generated by Valgrind. If you do not use Valgrind to check for memory errors in this 
assignment, you will need to do so in future ones.

###Debugging Valgrind Errors
Look for the *first* error, and debug that error. Sometimes you will get hundreds (or even hundreds of 
thousands) or errors; however, they may all caused by the same line of code. So just debug the first problem you 
encounter in the "memcheck.log" file.

Most memory errors fall into one of four categories:
#1 "Invalid read of size X", where X is a number. This means that you are reading X bytes of memory that you do 
not have access to. 
#2 "Invalid write of size X", as above, except that you are *writing* memory. Writing means, that the memory 
access is on the left-hand side of an "=" sign. (i.e., assignment operation, e.g. x = 5.) 
#3 "X bytes in 1 blocks definitely lost in loss record U of V", which means that you have asked for X bytes of 
memory, but never freed them.
#4 "Conditional jump or move depends on uninitialized value(s)" A conditional jump or move is what happens in 
an if statement or a for loop, where some condition (e.g., if(x > 5) {...}) determines the next line of code 
that is executed. If the memory is uninitialized (e.g., "x" has not been set), then the program behavior is 
random. When you see this error, look at the involved statement and ask yourself how any involved variables 
could be uninitialized.

These memory errors can be difficult to solve, but it is much easier if you think carefully about your code and 
understand what exactly each line is doing. This is necessary skill that you will use in future programming 
projects beyond this course.

#####Using gdb#####
Gdb is one of the world's most important debuggers. A debugger is a virtual environment 
that you run your code within. This environment allows you to control the execution of the code, 
and watch what happens to the variables. Using gdb will prove to be immensely useful for helping 
you debug your code.

To pass this assignment, you must submit a gdb log file. To produce a log file you must turn 
logging on. One way to do this is to use command-line flags to tell gdb to set logging on. After compiling you 
code (with a.out as the specific object file), you would type the following command:

> gdb -ex "set logging overwrite on" -ex "set logging on" ./a.out

You can learn how to set breakpoints and more by looking at the gdb man page (type "man gdb" without quotes) or
by running gdb (type "gdb") and then typing "help" (without quotes)

#####Assignment Submission#####
This assignment is different than the previous two in that you will be submitting multiple 
items. Please include the following items in a zip file:

#1 answer03.c, your solution
#2 main.c, a file with a bug in it that you must fix
#3 memcheck.log, a Valgrind log that is generated when your a.out program is run with the program Valgrind
#4 gdb.txt, a log generated when you run your a.out program with gdb

Information on generating the gdb and Valgrind logs is provided in the Using Valgrind and Using gdb sections of this README.
You will need to submit a log file produced by Valgrind when you run a.out (the object file generated when you 
compile main.c). 

For the gdb log file, you must set (at least) one breakpoint, step though your code, print the values of (at 
least) one variable, and then quit gdb. 

If you are unable to resolve the bug in main.c, generate the logs with the program anyway. The idea is to show 
that you have used Valgrind and gdb.

To create a zip file of these files, use the following command:

> zip pa03.zip answer03.c main.c memcheck.log gdb.txt

Your zip file must meet the above specifications. Failure to meet these specifications may result
in a SCORE OF ZERO for this assignment.

Once you have created pa03.zip, submit it to Blackboard. Do NOT submit the files separately.

#####ACCESS######
For this assignment, only half of the class should be able to use this assignment on ACCESS. If you are using 
ACCESS, please remember to put all of the functions into answer03.c and to generate gdb and Valgrind logs on 
your ECN account as explained on Blackboard (you will not be able to do this on ACCESS).

#####Grading#####
You must include the memcheck.log and gdb.txt files as a part of your submission or else your total grade for 
this assignment will be halved (so if based on the functions you wrote you got an 84% but you forgot the log 
files, you would get a 42% instead). 

There are 6 functions to complete in answer03.c plus the bug to fix in main.c. Successfully writing explode is worth 22%, the 
remaining 6 tasks (the 5 functions plus the bug in main.c) are worth 13% each. 

If your program has any errors (that prevent it from executing), compilation warnings, or memory leaks, you will 
fail the assignment. Use Valgrind or the built-in Memory tool on ACCESS to check for memory leaks. 

#####USEFUL INFORMATION#####

#1 Passing a char * * in strcat_ex
Read about the swap function in the chapter on pointers in the textbook. It is important to appreciate that a function can never edit a value outside of itself unless you pass a pointer (pass by reference). So swap(int, int) can never work. You must write swap(int *, int *).

The same thinking goes for strcat_ex(char * * dest, int * n, const char * src).

The amount of bytes available at dest (stored at address n) may not be enough to store the final concatenated 
string. So you need to do a new malloc, and then update the value of *dest, and also *n. That means that 
strcat_ex(...) must be able to edit these values from inside its function body. There is no way to do this 
without passing a pointer to these values.

If you want to edit an int value outside of the function it was declared, then you must pass an int *.

If you want to edit a char * value outside of the function it was declared, then you must pass a char * *.

#2 Memory errors in strcat_ex(...)
Be careful to not write code like this:

int src_len = strlen(src); 
int dst_len = strlen(*dest); 
if( (src_len + dst_len + 1 > *n) || (*dest == NULL)) { 
 // etc..  
}

Carefully read the instructions for strcat_ex, and note the *dest could be NULL. If it is NULL then we always 
allocate a new buffer. But there are two problems with the above code.

Firstly, calling strlen(*dest) is an error if *dest is NULL. That is because the NULL pointer is not a string! 
Remember, a string is a pointer to valid memory, and if you go to that memory, you will find a sequence of 
characters that ends in a null terminator, '\0'. The NULL pointer is *not* a string. NULL is an address that has 
no meaningful value in it. So calling strlen(*dest) will cause a segfault on most implementations.

Secondly, if *dest is NULL, then there is no guarantee that *n has been initialized -- and why should there be? 
*dest is not even a valid memory location, so why should it have a length? If *n has not been initialized, then 
calling:

   (src_len + dst_len + 1 > *n)

has an unpredictable result. It is a memory error.

However, it is perfectly okay to write this:

  if( (*dest == NULL) || (src_len + dst_len + 1 > *n) ) { 
     // etc..  
  }

Because *n is not evaluated if *dest is NULL.

#3 Tackling explode(...)

First you need to figure out how many delimiter characters appear in the string. You do this by calling 
strchr(delims, str[ind]) on each character in 'str'.  If you get NULL, then str[ind] is not a delimiter. If you 
get non-NULL, then that character is a delimiter.

The return result of explode(...) is an array of strings. A string is char *, so an array of strings is char * 
*. If there are N delimiters in 'str', then the returned array must have space for (N+1) strings.

So why is it (N+1)? If the string has no delimiters, then you just return the string. If it has 1 delimiter, 
then you split it in one place, and get two strings. If there are two delimiters, split it in two places to get 
three strings. In general, the presence of N delimiters means you split the string in N places to (N+1) strings.

The pseudo-code so far looks like this:

// Count how many delimiters are in 'str'
int N = 0;
for each character in 'str' {
   if strchr(delims, str[ind]) != NULL then increment N
}

// Create the return array
char * * strArr = malloc((N+1) * sizeof(char *));

Now that we have gotten this far, TEST YOUR CODE before proceeding to make sure it works up to this point. It is 
easier to debug your program as you go instead of all at the end.

Okay, now we have allocated some memory for the return result, we must fill it in.  To do this, we need to keep 
track of _two_ indices, call them "last" and "ind".  You want "last" to point to 1 past the last observed 
delimiter, and "ind" to point to the current character we are looking at. 

The following pseudo-code explains how to use these two indices to
initialize the first N strings in strArr:

int arrInd = 0; // this is the next position where we'll create a string
int last = 0; // 1 + the last index we saw a delimiter. Init to 0.
for each ind from [0..strlen(str)), do {
    if str[ind] is a delimiter, then... {
        create a new string that spans the characters [last..ind)
	set strArr[arrInd] to that new string.
        set last to ind + 1.
	increment arrInd
    }
}

Before proceeding, TEST YOUR CODE, to make sure it works perfectly so far.

Okay, so far we've initialized the first N string, but we still have to do the (N+1)th string. This is done in the same way 
as above:

// just take the remaining characters of the string
create a new string that spans the characters [last..strlen(str))
set strArr[N] to the new string.

Do not forget that you must store the length of strArr at the memory location *arrLen. You need to do this so 
that when someone calls explode(...), they will be able to know how long the returned string array is.

You will save yourself a lot of time if you write and test this code incrementally.